{"pageProps":{"slug":"nextjs","posts":[{"slug":"type-narrowing-and-closures","meta":{"title":"Type narrowing and closures","short":"Typescript offers a mechanism called type narrowing, which allows us to validate object's type with type guards and avoid explicit casts or error silencing. This post will give a brief demo of this feature and show it's interesting consequences.","tags":"typescript","published":"2020-05-25T00:00:00.000Z","background":"#181f2b"},"content":"\n# Type narrowing\n\nIf you've worked with Typescript before, chances are you've already came across type narrowing. Let's consider a function that checks if a user has permissions for actions passed as an array of strings.\n\n```typescript\nfunction canUser(user: User, permissions: string[]): boolean {\n    return permissions.every(permission =>\n        user.permissions.includes(permission));\n}\n\nif (canUser(mike, ['todo.create', 'todo.update'])) {\n    // ...\n}\n\nif (canUser(tom, ['piano.play'])) {\n    // ...\n}\n```\n\nPretty simple. Let's improve the API a bit. Passing a single string instead of an array with one element will save developers some typing.\n\n```typescript\nfunction userCan(\n    user: User,\n    permissions: string | string[]): boolean {\n\n    if (typeof permission === 'string') {\n        // typescript knows that in this\n        // scope permission is a string\n        return user.permissions.includes(permission);\n    } else {\n        // in this scope permission can not be\n        // a string, so it's an array\n        return permissions.every(permission =>\n            user.permissions.includes(permission));\n    }\n}\n\nif (userCan(ben, 'car.drive')) {\n    // ...\n}\n```\n\nType narrowing is occurring inside the if condition. In the first branch, the type `string | string[]` is narrowed to `string`. In else branch, Typescript assumes that the code will execute only if `permissions` is an array of strings.\n\nDoes `typeof` have special powers? No. `typeof` operator is a **type guard**. Its boolean result determines if a broader type (in this case union of two types) can be narrowed down. A function that you probably know by now - `Array.isArray` - is a type guard. We can define our own type guards too. Here is how they look like.\n\n```typescript\ntype CartesianPoint = {\n    x: number;\n    y: number;\n}\n\nfunction isCartesianPoint(obj: any): obj is CartesianPoint {\n    return !!obj &&\n        typeof obj === 'object' &&\n        typeof obj.x === 'number' &&\n        typeof obj.y === 'number';\n}\n\nfunction drawCartesianPoint(point: CartesianPoint) {\n    // draw on the screen\n}\n\nfunction draw(obj: object) {\n\n    // this will give a compile time error,\n    // because obj might not be a point\n    drawCartesianPoint(obj);\n\n    if (isCartesianPoint(obj)) {\n        // this compiles, because type guard\n        // guarantees that the object is a point\n        drawCartesianPoint(obj);\n    }\n}\n```\n\nIf you want to read more about type guards, check out [Typescript's handbook](https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards).\n\n# Simple feature, huh?\n\nI recently run into a scenario that exposes a weird quirk of type narrowing. Take a look.\n\n```typescript\nfunction access(index: number, data: any[] | Map<number, any>) {\n  let indirection = data; // notice let\n\n  if (Array.isArray(indirection)) {\n    const x = indirection[index];\n    const y = () => indirection[index]; // error\n    const z = (() => indirection[index])();\n  }\n}\n```\nThe error message says:\n\n> No index signature with a parameter of type 'number' was found on type 'any[] | Map<number, any>'.\n\nWait, what? I though Typescript would narrow down `indirection` to array type. And it did it when initializing `x`. What's wrong with `y`?\n\nType narrowing does not work when a `let` variable is captured by a function. Changing `let` to `const` fixes the error above. Seems weird at first glance, but it actually makes sense! Imagine that **after** creating function `y` we set variable `indirection` to a map and **then** call `y`.\n\n```typescript\nfunction access(index: number, data: any[] | Map<number, any>) {\n  let indirection = data; // notice let\n\n  if (Array.isArray(indirection)) {\n    const y = () => indirection[index];\n    indirection = new Map<number, any>();\n    y(); // ?\n  }\n}\n```\n\nThe call to `y` yields `undefined` because one line above `indirection` reference was set to a map, which does not have numerical properties. If `indirection` was declared with `const`, reassignment would not be allowed and thus the array guarantee would be always valid.\n\nIt's fascinating how Typescript tracks type changes. The difference in behavior between `let` and `cost` captured variables reminds me of Rust's borrow checker. `y` borrows `indirection`, which should not be changed until `y` is destroyed. Otherwise, the array invariant is broken. Interestingly, an IIFE assigned to `z` in the previous example does not trigger that error. Maybe Typescript noticed that the borrow immediately disappears and type may stay unchanged?\n"},{"slug":"a-static-blog","meta":{"title":"A static blog?","short":"Following the hype, I wanted to play with the new generation of static page generators. Without too much thinking I started writing this personal blog in Next.js. As I later discovered, Next has a different purpose. Let me tell you about the creation of this static blog and my adventure with Next.js.","tags":"markdown,nextjs","published":"2020-05-25T00:00:00.000Z","background":"#141407"},"content":"\n# The idea\n\nIn late 2010s static site generators hit the mainstream once again. Quite a surprising turn considering that the tech world generally heads towards interactivity, which is not a strong side of static pages. So... why did that happen? I can think of four possible reasons. First of all, static pages load instantly, as they are pre-rendered and don't contain heavy JavaScript. Secondly, static sites can be hosted cheaply just about anywhere. Another benefit is the lack of maintenance overhead. No security patches and no database backups needed, how does that sound? The last reason, and probably the most relevant one, is **nostalgia**. Web developers, just like other homo sapiens, can sometimes look at the world through rose-tinted glasses. Serving static HTML files smells like the early world wide web and might feel a bit nostalgic.\n\nExcited by the concept and new tools, I decided to create a personal blog. The first step was to select a framework. I went with **Next.js**, which seemed appealing mostly because of its use of **React.js** for rendering. Looking back at it now, it wasn't the best choice. Not because Next is bad, but because generating static HTML is just the tip of the Next.js iceberg. More on that in a second. After finishing my dissertation project, I found time to finish off the blog and work on the content. I'm really happy with the final result and excited to share the insides of the project with you.\n\n# Next.js\n\nNext's presence on multiple \"top N static page generators\" lists might be a bit misleading. While it can output static HTML, the goal of this tool is to serve pre-rendered pages without sacrificing client-side interactivity. It does that by matching routes on the server-side, rendering the initial content, and returning the generated HTML to the client. Scripts included in the markup pull React components and their dependencies to recreate the state of the React app that rendered the page. When that process finishes, React runs as if nothing has happened. This technique is called **rehydration** and it allows developers to serve useful content without loading screens. What a clever solution!\n\nHowever, my blog doesn't need rehydration because its pages are truly static. The only thing I am interested in is the output of the initial render. Luckily, Next.js contains [an experimental feature](https://github.com/zeit/next.js/pull/11949) that disables rehydration on selected pages. With it, I removed unnecessary scripts and saved around 300kB on the post page. All that's left to do is to render a set of pages to HTML files. This can be done with a few short functions and commands.\n\n# Execution\n\nMy attempt at creating a blog was heavily guided by the articles below. Check them out if you want to learn about reading and rendering Markdown documents.\n\n- [\"Creating a Markdown Blog with Next.js\" by Kendall Strautman](https://dev.to/tinacms/creating-a-markdown-blog-with-next-js-52hk)\n- [\"React Markdown — Code and Syntax Highlighting\" by Bexultan A. Myrzatayev](https://medium.com/young-developer/react-markdown-code-and-syntax-highlighting-632d2f9b4ada)\n\nLet's take a look at the structure of my blog and examine interesting parts closely.\n\n```\n.\n├── README.md\n├── package.json\n├── next.config.js\n├── crop_header.sh\n├── crop_post.sh\n├── crop.py\n├── public\n│   └── assets\n│       ├── favicon.ico\n│       ├── avatar.webp\n│       ├── <more public assets>\n│       └── type-narrowing-and-closures\n│           ├── README.md\n│           ├── header-m-1x.webp\n│           └── <more post assets>\n├── data\n│   ├── config.json\n│   └── tags.json\n├── posts\n│   ├── type-narrowing-and-closures.md\n│   └── <more posts>\n└── src\n    ├── pages\n    │   ├── _app.js\n    │   ├── index.js\n    │   ├── posts\n    │   │   └── [slug].js\n    │   └── tags\n    │       └── [slug].js\n    ├── components\n    │   ├── PostHeader.js\n    │   ├── PostFooter.js\n    │   └── <more components>\n    ├── styles\n    │   ├── global.css\n    │   ├── variables.css\n    │   ├── index.css\n    │   ├── post-header.css\n    │   └── <more styles>\n    └── utils.js\n```\n\n# Image processing for responsive images\n\nAs you know, responsive webpages should adapt to different viewports (mobile, tablet, desktop) and different pixel-density displays. If that was not complicated enough, some browsers don't support modern image formats (yes, I'm looking at you, Safari). Manual cropping, scaling and converting input images, so that they cover all possible scenarios, would take forever. That's why I created a few tools for automating this task. `crop.py` is a python script for image manipulation. Just like ImageMagic, but with a usable interface 😛. `crop_header.sh` uses that tool to turn an input header image into multiple variants ready for display on post pages. `crop_post.sh` is similar but produces images for display in post content.\n\nWhile `crop_post.sh` only scales the image, the header cropping script extracts central area an input image maintaining the desired aspect ratio for different viewport sizes.\n\n![Crop frames](crop-frames \"Frames showing how the original header image will be cropped for different viewports.\")\n\nHere is how I run these two scripts.\n\n```bash\nbash crop_header.sh ~/input.jpg public/assets/post-slug/\nbash crop_post.sh ~/input.jpg public/assets/post-slug/ new-name\n```\n\nAsking the browser to display correct files is quite challenging too. [Responsive images article](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) on MDN is an invaluable resource when working with the `picture` tag and the `srcset` attribute. The following snippet contains instructions for displaying mobile sized _webp_ header images in two pixel density variants. In the real header component I repeated the source element for all image formats and all viewport sizes!\n\n```jsx\n<picture>\n  <source\n    type=\"image/webp\"\n    media=\"(max-width:  480px)\"\n    srcSet={`/assets/${slug}/header-s-2x.webp 960w,\n             /assets/${slug}/header-s-1x.webp 480w`}\n  />\n  {/* more sources here */}\n  <img\n    src={`/assets/${slug}/header-m-1x.jpg`}\n    alt=\"header image\"\n  />\n  </picture>\n```\n\n# Public assets\n\n`public/assets` folder contains assets like icons and avatars. Because Next.js copies contents of `public` folder into the build folder, webpages can reference assets using URLs starting with `/assets`, e.g. `<img src=\"/assets/avatar.webp\" alt=\"\" />`.\n\n`public/assets/<post-slug>` folders store assets used by posts with matching slugs. These are mostly images created by the previously mentioned `crop_header.sh` and `crop_post.sh` scripts. README files are for asset credits.\n\n# Content\n\n`data` directory is a place for **JSON** files with global data used by the blog. `config.json` stores author data and webpage title. `tags.json` contains all post tags, as well as their titles and colors. These files are loaded by page components, which will be described later.\n\n`posts` folder contains my **Markdown**-formatted posts. The name of a Markdown file is used as a slug in post URLs, e.g. `/posts/type-narrowing-and-closures`. Every document starts with **YAML front matter** describing metadata of a post. That metadata lands in many places in the rendered HTML: on post's page, in previews, and head's `title`, and `meta` elements.\n\n```yaml\n---\ntitle: \"This is my post\"\nshort: \"Here is its short description shown in previews.\"\ntags: \"javascript,typescript\"\npublished: 2020-01-01\nbackground: \"#282828\"\n---\nDocument content goes here...\n```\n\n# Routing\n\nA typical React application decides what content should be shown by matching URL after the app has started. In Next.js, routes are represented by **page files** and folders inside `src/pages`. The root page `/` is rendered by `index.js`. `/hello` would try to render `hello.js`, and nested URLs like `posts/first` would search for `posts/first.js`. Simple stuff so far.\n\nRoutes can be more dynamic. If a file name contains parameters in square brackets, e.g. `tags/[slug].js`, it will match many URLs, e.g. `/tags/javascript`, `/tags/react`, `/tags/next`. JavaScript page files can access these parameters and render different content for different URLs.\n\nMy blog uses the following files to render posts, tags and the index page.\n\n```\nsrc/pages/index.js\nsrc/pages/posts/[slug].js\nsrc/pages/tags/[slug].js\n```\n\nHow do we tell Next.js what URLs it should render during a build? Using `getStaticPaths` function. When exported from a page file, this function tells the \"compiler\" to render pages with different parameters. The following snippets show how I request the generation of tag pages.\n\n```javascript\n// src/pages/tags/[slug].js\n\nexport async function getStaticPaths() {\n  const tags = (await import('../../../data/tags.json')).default;\n\n  return {\n    fallback: false,\n    paths: Object.keys(tags).map(slug => ({\n      params: { slug },\n    })),\n  };\n}\n```\n\n```javascript\n// data/tags.json\n\n{\n  \"typescript\": {\n    \"title\": \"TypeScript\",\n    \"color\": \"#294e80\"\n  },\n  \"markdown\": {\n    \"title\": \"Markdown\",\n    \"color\": \"#000000\"\n  },\n  // ...\n}\n```\n\n# Pages\n\nSingle page applications fetch data from APIs asynchronously. In Next, page components are not rendered until the exported `getStaticProps` function resolves with page props. This function is a good place to ask an API for data or read files from disk before you render the HTML.\n\nWarning: `getStaticProps` works only with static generation. For server-side rendering, you need to implement `getServerSideProps` function.\n\nHere is how I prepare data for post rendering.\n\n```jsx\n// src/pages/posts/[slug].js\n\nimport { getPosts } from '../../utils';\n\nexport async function getStaticProps(context) {\n  // extract slug from url\n  const { slug } = context.params;\n\n  // read config, tags and posts\n  const config = (await import('path-to-config-json')).default;\n  const tags = (await import('path-to-tags-json')).default;\n  const posts = getPosts();\n\n  // find the post to render + its neighbors\n  const index = posts.findIndex(post => post.slug === slug);\n\n  const post = posts[index];\n  const nextPost = posts[index-1] ?? null;\n  const prevPost = posts[index+1] ?? null;\n\n  // prepare props\n  const props = { post, nextPos, PrevPost, config, tags };\n\n  // return JSON-compatible version of props\n  return {\n    props: JSON.parse(JSON.stringify(props)),\n  };\n};\n\n```\n\nIf you're wondering how `getPosts` function looks like, check this out. It's not that scary! It simply reads posts as text files and separates metadata from content using `gray-matter` library. Post are sorted by date, so I can show them in a sensible order.\n\n```javascript\n// src/utils.js\n\nimport matter from 'gray-matter';\n\nexport function getPosts() {\n  // read files from 'posts' directory\n  const dir = require.context('../posts', true, /\\.md$/);\n  const fileNames = dir.keys();\n  const fileValues = fileNames.map(dir);\n\n  const posts = fileNames.map((name, i) => {\n    // slug = name without extension\n    const slug = name.match(/\\/([\\w-]+)\\.md$/)[1];\n\n    // parse text to separate metadata from content\n    const parsed = matter(fileValues[i].default);\n    const meta = parsed.data;\n    const content = parsed.content;\n\n    // post = slug + meta + content\n    return { slug, meta, content };\n  });\n\n  // sort posts by publish date\n  posts.sort((a, b) => b.meta.published - a.meta.published);\n  return posts;\n}\n```\n\nWhen the data is ready, Post component takes over and generates virtual HTML with post's content. Here is a simplified version of the post component:\n\n```jsx\n// src/pages/posts/[slug].js\n\nexport default function Post({ post, nextPost, prevPost }) {\n  return (\n    <div>\n      <Head>\n        <title>{post.meta.title}</title>\n        <meta name=\"description\" content={post.meta.short} />\n        {/* other metadata */}\n      </Head>\n\n      <PostHeader post={post} />\n\n      <ReactMarkdown\n        source={post.content}\n        renderers={{\n          code: Code,\n          paragraph: Paragraph,\n          image: props => <Image {...props} slug={post.slug} />\n        }}\n      />\n\n      <PostFooter />\n    </div>\n  );\n}\n```\n\n**ReactMarkdown** component from 'react-markdown' library turns my post documents into HTML. Notice how I override default renderers of that element. The `paragraph` renderer adds additional classes to paragraphs stating with text so that I can style them differently. The `image` renderer is quite interesting. It creates a figure with caption, making illustrations included in posts look a bit more professional. Furthermore, it renders images with a `picture` element containing both high and low pixel density images. `code`, as you might have guessed, renders code snippets with syntax highlighting.\n\nThe last piece of the puzzle is disabling rehydration. Hey, do you remember what it is? We can do that by exporting a config object from page components, just like that:\n\n```javascript\nexport const config = {\n  unstable_runtimeJS: false,\n};\n```\n\n# Other code\n\n## `_app.js`\n\n`_app.js` is an optional file living in `pages` folder. It's useful for customizing the \"React bootstrapping\" process. If you want to import global CSS or add head elements, like `link`, `script`, or `meta`, to all pages, this is the right place. Because of Next's early route matching, the application component receives matched page component and props, including URL parameters. All you need to do is render that page, like so:\n\n```jsx\n// src/pages/_app.js\n\nimport Head from 'next/head';\n\nimport '../styles/variables.css';\nimport '../styles/global.css';\nimport '../styles/post.css';\n// more css imports here\n\nexport default function App({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        {/* favicon, meta, stylesheets, and scripts go here */}\n        <link href=\"my-font-source\" rel=\"stylesheet\" />\n      </Head>\n      {/* render the page */}\n      <Component {...pageProps} />\n    </>\n  );\n}\n```\n\n## Styles\n\nNext.js comes with support for **CSS modules** (`.module.css`). Their per-file class name mangling is a great solution to CSS collision problems. While CSS modules can be imported from any JavaScript file, the traditional CSS can only be imported in `_app.js`. That's exactly where I put all my stylesheets since this project relies on global CSS exclusively.\n\nI must mention the use of **CSS variables**. For some strange reason, the community has not adopted that technology, despite its [high browser compatibility](https://caniuse.com/#search=css%20variables) (94.81% of browsers as of 2020-05). In my project, variables describing fonts, font sizes, and colors live in the `variables.css` file. Styles shared between pages are placed in `global.css`. All other CSS files are responsible for styling components.\n\nTo cope with class collisions and give stylesheets a solid backbone, I followed [BEM methodology](http://getbem.com/). Well, with some small modifications. I name BEM components with _PascalCase_ and BEM elements with _camelCase_. All in all, I am really happy with how styles turned out. My blog looks pretty both in the browser and in the editor!\n\n## Components\n\nSeparating independent units of the user interface is a common practice in front-end frameworks. It encourages reusability and makes complex applications more manageable. Components of this blog live in `src/components` folder.\n\n# Results and conclusion\n\nThe source code of the blog is [available on GitHub](https://github.com/prk3/blog-source). Generating truly static and lightweight pages required a bit of effort, mostly because of rehydration, which can be disabled only with the undocumented, experimental feature of Next. All in all, I am happy with the result and will definitely put the blog into use.\n\nWould I use static generation in serious, not \"for-fun\" projects? Probably not. It's hard to deny that static pages are not very useful these days. Even the most obvious use cases of static site generation, like blogs or documentation pages, benefit greatly from dynamic content such as comments or search results. Maybe it's good enough for static portfolio pages? In the end, if you need to make a hole in a slice of bread, it does not matter if you use your finger, a screwdriver, or an electric drill.\n\nNext.js is not a regular static site generator. It's a framework that brings together the best of three worlds: static generation, server-side rendering, and client-side interactive interfaces. If you think how React applications are usually loaded and run, you realize that with Next's server-side rendering you can speed up the initial render by skipping up to 3 sequential HTTP requests. This is a massive improvement especially for users with a poor internet connection. I would like to see how Next is used in more complex products. Are the benefits worth the transition from pure React? Does Next maintain the separation of back-end logic from user interface logic?\n"}],"tags":{"typescript":{"title":"TypeScript","color":"#294e80"},"markdown":{"title":"Markdown","color":"#000000"},"nextjs":{"title":"Next.js","color":"#000000"}},"config":{"author":{"name":"Przemysław Kukulski","email":"kukulski.przemyslaw@gmail.com"},"title":"prk3 blog"}},"__N_SSG":true}