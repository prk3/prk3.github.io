{"pageProps":{"slug":"typescript","posts":[{"slug":"functional-tetris","meta":{"title":"Tetris in functional style","short":"How hard is it to write a clone of Tetris? That depends on how you approach that challenge. After one unsuccessful attempt, I decided to write Tetris is a functional style. This is a story of how a just-for-fun project changed they way I see and write software.","tags":"functional","published":"2020-11-25T00:00:00.000Z","background":"#272427"},"content":"\n# The beginning of Super Average Tetris\n\nFor a while in my software development career, I've been struggling with designing programs and deciding how to structure code. The object-oriented paradigm, which I have been exposed to at university, suggests defining distinct \"things\" that play some role in the system, and writing a class for each \"thing\". Methods on the classes would then reflect real-world interactions between \"things\". I used this strategy when working on a small, just-for-fun project: a clone of the famous Tetris game named Super Average Tetris. I must confess, my first attempt was a total disaster.\n\nTo explain why that was the case, let's design a Tetris game in OOP way. First question: What are the \"things\" in Tetris? There is a board with non-moving cells and the block that moves. And that's pretty much all to it. Easy peasy.\n\nQuestion no. 2: How do objects interact with each other and what are their responsibilities? Well, it's not trivial to figure that out. Who initiates actions in the game? The block or the board? Or maybe there should be some player/god class that would send commands to either of them? We have not thought of that one before. Does the \"move down on timeout\" come from the same place as the user's \"move left\" command? Btw. is it the board that owns the block or the block that owns the board? Or maybe they must be coupled together? Who's responsible for creating a new block when the old lands on board cells? Who checks for game end condition?\n\nEven a non-complex system, such as Tetris, forces a developer to explore dozens of solutions. The number of \"paths\" one can take grows quickly as the number of \"things\" increases. Each decision point can rule out other decisions, sometimes contradicting those made earlier.\n\nI've been repeatedly redefining responsibilities of \"things\" and interactions between objects in my Tetris project. Every structure I came up with felt wrong in one way or another. I left the project for a few months, before I came back to it, this time wanting to try a functional approach.\n\nWith a functional mindset, we can express any game as a sequence of states (plain data), each one being a combination of the previous state and user input. We give up on the idea of actors interacting with each other in favor of an anonymous executor defining how states (plain data) are transformed. Let's try that! We must answer three questions to design a functional Tetris.\n\n## Question 1: What is the state is Tetris?\n\nThe first element of Tetris state is the board: the board is just a grid of cells, each cell can be either occupied or empty. An occupied cell can have a color. The board could be easily represented with a 2-dimensions array of numbers. That's it.\n\nWhat about the movable block? While it seems to be just a bunch of board cells, it can move independently from board cells. Just like if it was another board sliding over the proper board and covering a chunk of the board. Again, a 2-dimensional array would do the job.\n\nWhile we are on the topic of sliding the block over the board, I must mention that the \"slide\" is also a part of the state. I call it position, and it's just a 2D vector - an offset of the block in relation to the top-left corner of the board. Notice that **the block position belongs to the state, not the block**. Why? Because the block is just a bunch of cells. It does not need to know anything about the world it's in.\n\nWhat about rotation? Is it kept in the state too? Nope. A rotated block is just a different block, so theoretically rotation does not have to be remembered*.\n\n\\* Some block types in Testis don't have 4 \"intuitive\" rotations. For that reason, I track what rotation they are in. That does not change the fact that rotation operation produces a new block.\n\n## Questions 2: What is the input in Tetris?\n\nUser input is one of the following commands:\n- move left\n- move right\n- move down\n- rotate left\n- rotate right\n- time's up!\n\nNotice that input contains both user commands and \"time's up!\" coming from the game. Input represents anything that causes the game to update and has a potential impact on the next state.\n\n## Question 3: How do we transform the state?\n\nIf the player moved left, right, or down, we to check if that move is legal, that is: the **cells of a block** with updated position **do not collide with cells on the board**\\*. If that's the case (the move is legal), we copy the state replacing the position with a new one. If not, the new state will be the same as the old state.\n\nRotation, both to the left and right, works almost the same as move. We create a new, rotated block and check if **it does not collide with the board**. If that's the case (the move is legal), we copy the state replacing the block with a new one. Otherwise, the state will stay the same.\n\nNow the last input variant. To handle \"time's up\", we check if a move down is legal, that is whether **a block** moved down by one **would not collide with the board**. When the move is legal, the new state will have the position replaced. Otherwise, we replace the board, the block, and the block position. The new board is **the old board with the block merged into it**. Additionally, **full rows are removed from the board**. The block is replaced with a new, random block and the position is reset to the top.\n\n\\* Collision happens when the block covers any cell of the board **or** any cell of the block sticks out of the board. This way we handle going too far to the sides or hitting the bottom of the board.\n\n## Done? Yes.\n\nBelieve it or not, the design is ready. Now we have to turn input and state into data types, and implement transitions. I highlighted 3 fundamental operations in **bold**. These are:\n\n- detecting if a block collides with a board\n- merging a block with a board to produce a new board\n- removing full rows from a board\n\nThey aren't that hard to implement and once you're done, the rest is trivial.\n\n## Lessons learned\n\nThe Tetris could likely be designed in OOP way. Maybe I missed some combination of decisions that would produce a viable design. Maybe the solution was to merge the board and block into one entity because they must be closely coupled. Whatever is the case, I think that the OOP design process (at least the one I followed) is flawed. It focuses on actors and their interactions, ignoring the data because \"it's an implementation detail\". The goal of OOP - organizing code into isolated and manageable units - is noble, but I can stand in the way of discovering the essence of the problem you are trying to solve.\n\nMy second take on writing Tetris was successful because I approached the problem differently. I described Tetris in terms of the data and how the data changes. I found patterns in this description and turned them into functions defining the shape of an implementation.\n\nFinishing Super Average Tetris was one of a few factors contributing to a shift in the way I see and write software. First, I try to separate data from transformations. This goes against the rules of OOP, but makes the problem understandable. Second, I structure data in a way that makes transformations easy. Simulating real-world interaction between objects can make the code more convoluted. Third, I avoid mutating data and the state of objects whenever possible. Eliminating side-effects has a nice consequence of making code transparent - it can be examined and understood without knowing about all other things that happen in a program, including non-trivial interactions between objects.\n\n## Implementation\n\nMy Tetris implementation in Rust is available [on github](https://github.com/prk3/super-average-tetris). It adds a few details to the design created just above. Here are some of them:\n\n## The big switchâ„¢\n\nThe game loop is a literal loop with a big switch over the input. Each branch of the switch returns a new state. The function containing the switch is pretty long. I could split action handlers into separate functions, but hey... What's the point of adding more names? ;)\n\n## Collecting input\n\nUser input is collected in a separate thread and sent to the game loop through a channel. This clears up the update loop. However, some input related data ended up in the state. An example of that is how much time is left before the next \"time's up!\" input.\n\n## Block representation\n\nAlthough I treat it like a 2D array, cells of a block are represented with a 16-bit integer. This reduces the amount of memory used for block cells from 16 bytes to 2. Remember, this was a just-for-fun project.\n\nOh, a word about the color of a block. The color lives in the state, not inside the block. That's because I left it like that. It does not make sense at all, but I did not bother fixing it.\n\n## Drawing the game\n\nAt the start and after each update, the game is redrawn. How do we draw the game? We simply **merge the block** in its current position **with the board** (one of the fundamental operations, remember?), iterate through all cells of the resulting new board, and print block characters with an appropriate color. Simple stuff.\n\n## Not purely functional\n\nI implemented the game in Rust, which is not a functional language. While the game has a functional heart, some parts of the code are not functional - they mutate variables or use procedural-looking APIs. Examples? New states override the memory of the old state. Block generator, which serves blocks in a randomized order, uses a non-functional shuffling algorithm. Why not purely functional? Because some things are easier to code in non-functional styles. I believe it's better to take the best from many worlds rather than fanatically follow one paradigm.\n"},{"slug":"type-narrowing-and-closures","meta":{"title":"Type narrowing and closures","short":"Typescript offers a mechanism called type narrowing, which allows us to validate object's type with type guards and avoid explicit casts or error silencing. This post will give a brief demo of this feature and show it's interesting consequences.","tags":"typescript","published":"2020-05-25T00:00:00.000Z","background":"#181f2b"},"content":"\n# Type narrowing\n\nIf you've worked with Typescript before, chances are you've already came across type narrowing. Let's consider a function that checks if a user has permissions for actions passed as an array of strings.\n\n```typescript\nfunction canUser(user: User, permissions: string[]): boolean {\n    return permissions.every(permission =>\n        user.permissions.includes(permission));\n}\n\nif (canUser(mike, ['todo.create', 'todo.update'])) {\n    // ...\n}\n\nif (canUser(tom, ['piano.play'])) {\n    // ...\n}\n```\n\nPretty simple. Let's improve the API a bit. Passing a single string instead of an array with one element will save developers some typing.\n\n```typescript\nfunction userCan(\n    user: User,\n    permissions: string | string[]): boolean {\n\n    if (typeof permission === 'string') {\n        // typescript knows that in this\n        // scope permission is a string\n        return user.permissions.includes(permission);\n    } else {\n        // in this scope permission can not be\n        // a string, so it's an array\n        return permissions.every(permission =>\n            user.permissions.includes(permission));\n    }\n}\n\nif (userCan(ben, 'car.drive')) {\n    // ...\n}\n```\n\nType narrowing is occurring inside the if condition. In the first branch, the type `string | string[]` is narrowed to `string`. In else branch, Typescript assumes that the code will execute only if `permissions` is an array of strings.\n\nDoes `typeof` have special powers? No. `typeof` operator is a **type guard**. Its boolean result determines if a broader type (in this case union of two types) can be narrowed down. A function that you probably know by now - `Array.isArray` - is a type guard. We can define our own type guards too. Here is how they look like.\n\n```typescript\ntype CartesianPoint = {\n    x: number;\n    y: number;\n}\n\nfunction isCartesianPoint(obj: any): obj is CartesianPoint {\n    return !!obj &&\n        typeof obj === 'object' &&\n        typeof obj.x === 'number' &&\n        typeof obj.y === 'number';\n}\n\nfunction drawCartesianPoint(point: CartesianPoint) {\n    // draw on the screen\n}\n\nfunction draw(obj: object) {\n\n    // this will give a compile time error,\n    // because obj might not be a point\n    drawCartesianPoint(obj);\n\n    if (isCartesianPoint(obj)) {\n        // this compiles, because type guard\n        // guarantees that the object is a point\n        drawCartesianPoint(obj);\n    }\n}\n```\n\nIf you want to read more about type guards, check out [Typescript's handbook](https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards).\n\n# Simple feature, huh?\n\nI recently run into a scenario that exposes a weird quirk of type narrowing. Take a look.\n\n```typescript\nfunction access(index: number, data: any[] | Map<number, any>) {\n  let indirection = data; // notice let\n\n  if (Array.isArray(indirection)) {\n    const x = indirection[index];\n    const y = () => indirection[index]; // error\n    const z = (() => indirection[index])();\n  }\n}\n```\nThe error message says:\n\n> No index signature with a parameter of type 'number' was found on type 'any[] | Map<number, any>'.\n\nWait, what? I though Typescript would narrow down `indirection` to array type. And it did it when initializing `x`. What's wrong with `y`?\n\nType narrowing does not work when a `let` variable is captured by a function. Changing `let` to `const` fixes the error above. Seems weird at first glance, but it actually makes sense! Imagine that **after** creating function `y` we set variable `indirection` to a map and **then** call `y`.\n\n```typescript\nfunction access(index: number, data: any[] | Map<number, any>) {\n  let indirection = data; // notice let\n\n  if (Array.isArray(indirection)) {\n    const y = () => indirection[index];\n    indirection = new Map<number, any>();\n    y(); // ?\n  }\n}\n```\n\nThe call to `y` yields `undefined` because one line above `indirection` reference was set to a map, which does not have numerical properties. If `indirection` was declared with `const`, reassignment would not be allowed and thus the array guarantee would be always valid.\n\nIt's fascinating how Typescript tracks type changes. The difference in behavior between `let` and `cost` captured variables reminds me of Rust's borrow checker. `y` borrows `indirection`, which should not be changed until `y` is destroyed. Otherwise, the array invariant is broken. Interestingly, an IIFE assigned to `z` in the previous example does not trigger that error. Maybe Typescript noticed that the borrow immediately disappears and type may stay unchanged?\n"},{"slug":"a-static-blog","meta":{"title":"A static blog?","short":"Following the hype, I wanted to play with the new generation of static page generators. Without too much thinking I started writing this personal blog in Next.js. As I later discovered, Next has a different purpose. Let me tell you about the creation of this static blog and my adventure with Next.js.","tags":"markdown,nextjs","published":"2020-05-25T00:00:00.000Z","background":"#141407"},"content":"\n# The idea\n\nIn late 2010s static site generators hit the mainstream once again. Quite a surprising turn considering that the tech world generally heads towards interactivity, which is not a strong side of static pages. So... why did that happen? I can think of four possible reasons. First of all, static pages load instantly, as they are pre-rendered and don't contain heavy JavaScript. Secondly, static sites can be hosted cheaply just about anywhere. Another benefit is the lack of maintenance overhead. No security patches and no database backups needed, how does that sound? The last reason, and probably the most relevant one, is **nostalgia**. Web developers, just like other homo sapiens, can sometimes look at the world through rose-tinted glasses. Serving static HTML files smells like the early world wide web and might feel a bit nostalgic.\n\nExcited by the concept and new tools, I decided to create a personal blog. The first step was to select a framework. I went with **Next.js**, which seemed appealing mostly because of its use of **React.js** for rendering. Looking back at it now, it wasn't the best choice. Not because Next is bad, but because generating static HTML is just the tip of the Next.js iceberg. More on that in a second. After finishing my dissertation project, I found time to finish off the blog and work on the content. I'm really happy with the final result and excited to share the insides of the project with you.\n\n# Next.js\n\nNext's presence on multiple \"top N static page generators\" lists might be a bit misleading. While it can output static HTML, the goal of this tool is to serve pre-rendered pages without sacrificing client-side interactivity. It does that by matching routes on the server-side, rendering the initial content, and returning the generated HTML to the client. Scripts included in the markup pull React components and their dependencies to recreate the state of the React app that rendered the page. When that process finishes, React runs as if nothing has happened. This technique is called **rehydration** and it allows developers to serve useful content without loading screens. What a clever solution!\n\nHowever, my blog doesn't need rehydration because its pages are truly static. The only thing I am interested in is the output of the initial render. Luckily, Next.js contains [an experimental feature](https://github.com/zeit/next.js/pull/11949) that disables rehydration on selected pages. With it, I removed unnecessary scripts and saved around 300kB on the post page. All that's left to do is to render a set of pages to HTML files. This can be done with a few short functions and commands.\n\n# Execution\n\nMy attempt at creating a blog was heavily guided by the articles below. Check them out if you want to learn about reading and rendering Markdown documents.\n\n- [\"Creating a Markdown Blog with Next.js\" by Kendall Strautman](https://dev.to/tinacms/creating-a-markdown-blog-with-next-js-52hk)\n- [\"React Markdown â€” Code and Syntax Highlighting\" by Bexultan A. Myrzatayev](https://medium.com/young-developer/react-markdown-code-and-syntax-highlighting-632d2f9b4ada)\n\nLet's take a look at the structure of my blog and examine interesting parts closely.\n\n```\n.\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ next.config.js\nâ”œâ”€â”€ crop_header.sh\nâ”œâ”€â”€ crop_post.sh\nâ”œâ”€â”€ crop.py\nâ”œâ”€â”€ public\nâ”‚   â””â”€â”€ assets\nâ”‚       â”œâ”€â”€ favicon.ico\nâ”‚       â”œâ”€â”€ avatar.webp\nâ”‚       â”œâ”€â”€ <more public assets>\nâ”‚       â””â”€â”€ type-narrowing-and-closures\nâ”‚           â”œâ”€â”€ README.md\nâ”‚           â”œâ”€â”€ header-m-1x.webp\nâ”‚           â””â”€â”€ <more post assets>\nâ”œâ”€â”€ data\nâ”‚Â Â  â”œâ”€â”€ config.json\nâ”‚Â Â  â””â”€â”€ tags.json\nâ”œâ”€â”€ posts\nâ”‚Â Â  â”œâ”€â”€ type-narrowing-and-closures.md\nâ”‚Â Â  â””â”€â”€ <more posts>\nâ””â”€â”€ src\n    â”œâ”€â”€ pages\n    â”‚Â Â  â”œâ”€â”€ _app.js\n    â”‚Â Â  â”œâ”€â”€ index.js\n    â”‚Â Â  â”œâ”€â”€ posts\n    â”‚Â Â  â”‚Â Â  â””â”€â”€ [slug].js\n    â”‚Â Â  â””â”€â”€ tags\n    â”‚Â Â      â””â”€â”€ [slug].js\n    â”œâ”€â”€ components\n    â”‚Â Â  â”œâ”€â”€ PostHeader.js\n    â”‚Â Â  â”œâ”€â”€ PostFooter.js\n    â”‚Â Â  â””â”€â”€ <more components>\n    â”œâ”€â”€ styles\n    â”‚Â Â  â”œâ”€â”€ global.css\n    â”‚Â Â  â”œâ”€â”€ variables.css\n    â”‚Â Â  â”œâ”€â”€ index.css\n    â”‚Â Â  â”œâ”€â”€ post-header.css\n    â”‚Â Â  â””â”€â”€ <more styles>\n    â””â”€â”€ utils.js\n```\n\n# Image processing for responsive images\n\nAs you know, responsive webpages should adapt to different viewports (mobile, tablet, desktop) and different pixel-density displays. If that was not complicated enough, some browsers don't support modern image formats (yes, I'm looking at you, Safari). Manual cropping, scaling and converting input images, so that they cover all possible scenarios, would take forever. That's why I created a few tools for automating this task. `crop.py` is a python script for image manipulation. Just like ImageMagic, but with a usable interface ðŸ˜›. `crop_header.sh` uses that tool to turn an input header image into multiple variants ready for display on post pages. `crop_post.sh` is similar but produces images for display in post content.\n\nWhile `crop_post.sh` only scales the image, the header cropping script extracts central area an input image maintaining the desired aspect ratio for different viewport sizes.\n\n![Crop frames](crop-frames \"Frames showing how the original header image will be cropped for different viewports.\")\n\nHere is how I run these two scripts.\n\n```bash\nbash crop_header.sh ~/input.jpg public/assets/post-slug/\nbash crop_post.sh ~/input.jpg public/assets/post-slug/ new-name\n```\n\nAsking the browser to display correct files is quite challenging too. [Responsive images article](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) on MDN is an invaluable resource when working with the `picture` tag and the `srcset` attribute. The following snippet contains instructions for displaying mobile sized _webp_ header images in two pixel density variants. In the real header component I repeated the source element for all image formats and all viewport sizes!\n\n```jsx\n<picture>\n  <source\n    type=\"image/webp\"\n    media=\"(max-width:  480px)\"\n    srcSet={`/assets/${slug}/header-s-2x.webp 960w,\n             /assets/${slug}/header-s-1x.webp 480w`}\n  />\n  {/* more sources here */}\n  <img\n    src={`/assets/${slug}/header-m-1x.jpg`}\n    alt=\"header image\"\n  />\n  </picture>\n```\n\n# Public assets\n\n`public/assets` folder contains assets like icons and avatars. Because Next.js copies contents of `public` folder into the build folder, webpages can reference assets using URLs starting with `/assets`, e.g. `<img src=\"/assets/avatar.webp\" alt=\"\" />`.\n\n`public/assets/<post-slug>` folders store assets used by posts with matching slugs. These are mostly images created by the previously mentioned `crop_header.sh` and `crop_post.sh` scripts. README files are for asset credits.\n\n# Content\n\n`data` directory is a place for **JSON** files with global data used by the blog. `config.json` stores author data and webpage title. `tags.json` contains all post tags, as well as their titles and colors. These files are loaded by page components, which will be described later.\n\n`posts` folder contains my **Markdown**-formatted posts. The name of a Markdown file is used as a slug in post URLs, e.g. `/posts/type-narrowing-and-closures`. Every document starts with **YAML front matter** describing metadata of a post. That metadata lands in many places in the rendered HTML: on post's page, in previews, and head's `title`, and `meta` elements.\n\n```yaml\n---\ntitle: \"This is my post\"\nshort: \"Here is its short description shown in previews.\"\ntags: \"javascript,typescript\"\npublished: 2020-01-01\nbackground: \"#282828\"\n---\nDocument content goes here...\n```\n\n# Routing\n\nA typical React application decides what content should be shown by matching URL after the app has started. In Next.js, routes are represented by **page files** and folders inside `src/pages`. The root page `/` is rendered by `index.js`. `/hello` would try to render `hello.js`, and nested URLs like `posts/first` would search for `posts/first.js`. Simple stuff so far.\n\nRoutes can be more dynamic. If a file name contains parameters in square brackets, e.g. `tags/[slug].js`, it will match many URLs, e.g. `/tags/javascript`, `/tags/react`, `/tags/next`. JavaScript page files can access these parameters and render different content for different URLs.\n\nMy blog uses the following files to render posts, tags and the index page.\n\n```\nsrc/pages/index.js\nsrc/pages/posts/[slug].js\nsrc/pages/tags/[slug].js\n```\n\nHow do we tell Next.js what URLs it should render during a build? Using `getStaticPaths` function. When exported from a page file, this function tells the \"compiler\" to render pages with different parameters. The following snippets show how I request the generation of tag pages.\n\n```javascript\n// src/pages/tags/[slug].js\n\nexport async function getStaticPaths() {\n  const tags = (await import('../../../data/tags.json')).default;\n\n  return {\n    fallback: false,\n    paths: Object.keys(tags).map(slug => ({\n      params: { slug },\n    })),\n  };\n}\n```\n\n```javascript\n// data/tags.json\n\n{\n  \"typescript\": {\n    \"title\": \"TypeScript\",\n    \"color\": \"#294e80\"\n  },\n  \"markdown\": {\n    \"title\": \"Markdown\",\n    \"color\": \"#000000\"\n  },\n  // ...\n}\n```\n\n# Pages\n\nSingle page applications fetch data from APIs asynchronously. In Next, page components are not rendered until the exported `getStaticProps` function resolves with page props. This function is a good place to ask an API for data or read files from disk before you render the HTML.\n\nWarning: `getStaticProps` works only with static generation. For server-side rendering, you need to implement `getServerSideProps` function.\n\nHere is how I prepare data for post rendering.\n\n```jsx\n// src/pages/posts/[slug].js\n\nimport { getPosts } from '../../utils';\n\nexport async function getStaticProps(context) {\n  // extract slug from url\n  const { slug } = context.params;\n\n  // read config, tags and posts\n  const config = (await import('path-to-config-json')).default;\n  const tags = (await import('path-to-tags-json')).default;\n  const posts = getPosts();\n\n  // find the post to render + its neighbors\n  const index = posts.findIndex(post => post.slug === slug);\n\n  const post = posts[index];\n  const nextPost = posts[index-1] ?? null;\n  const prevPost = posts[index+1] ?? null;\n\n  // prepare props\n  const props = { post, nextPos, PrevPost, config, tags };\n\n  // return JSON-compatible version of props\n  return {\n    props: JSON.parse(JSON.stringify(props)),\n  };\n};\n\n```\n\nIf you're wondering how `getPosts` function looks like, check this out. It's not that scary! It simply reads posts as text files and separates metadata from content using `gray-matter` library. Post are sorted by date, so I can show them in a sensible order.\n\n```javascript\n// src/utils.js\n\nimport matter from 'gray-matter';\n\nexport function getPosts() {\n  // read files from 'posts' directory\n  const dir = require.context('../posts', true, /\\.md$/);\n  const fileNames = dir.keys();\n  const fileValues = fileNames.map(dir);\n\n  const posts = fileNames.map((name, i) => {\n    // slug = name without extension\n    const slug = name.match(/\\/([\\w-]+)\\.md$/)[1];\n\n    // parse text to separate metadata from content\n    const parsed = matter(fileValues[i].default);\n    const meta = parsed.data;\n    const content = parsed.content;\n\n    // post = slug + meta + content\n    return { slug, meta, content };\n  });\n\n  // sort posts by publish date\n  posts.sort((a, b) => b.meta.published - a.meta.published);\n  return posts;\n}\n```\n\nWhen the data is ready, Post component takes over and generates virtual HTML with post's content. Here is a simplified version of the post component:\n\n```jsx\n// src/pages/posts/[slug].js\n\nexport default function Post({ post, nextPost, prevPost }) {\n  return (\n    <div>\n      <Head>\n        <title>{post.meta.title}</title>\n        <meta name=\"description\" content={post.meta.short} />\n        {/* other metadata */}\n      </Head>\n\n      <PostHeader post={post} />\n\n      <ReactMarkdown\n        source={post.content}\n        renderers={{\n          code: Code,\n          paragraph: Paragraph,\n          image: props => <Image {...props} slug={post.slug} />\n        }}\n      />\n\n      <PostFooter />\n    </div>\n  );\n}\n```\n\n**ReactMarkdown** component from 'react-markdown' library turns my post documents into HTML. Notice how I override default renderers of that element. The `paragraph` renderer adds additional classes to paragraphs stating with text so that I can style them differently. The `image` renderer is quite interesting. It creates a figure with caption, making illustrations included in posts look a bit more professional. Furthermore, it renders images with a `picture` element containing both high and low pixel density images. `code`, as you might have guessed, renders code snippets with syntax highlighting.\n\nThe last piece of the puzzle is disabling rehydration. Hey, do you remember what it is? We can do that by exporting a config object from page components, just like that:\n\n```javascript\nexport const config = {\n  unstable_runtimeJS: false,\n};\n```\n\n# Other code\n\n## `_app.js`\n\n`_app.js` is an optional file living in `pages` folder. It's useful for customizing the \"React bootstrapping\" process. If you want to import global CSS or add head elements, like `link`, `script`, or `meta`, to all pages, this is the right place. Because of Next's early route matching, the application component receives matched page component and props, including URL parameters. All you need to do is render that page, like so:\n\n```jsx\n// src/pages/_app.js\n\nimport Head from 'next/head';\n\nimport '../styles/variables.css';\nimport '../styles/global.css';\nimport '../styles/post.css';\n// more css imports here\n\nexport default function App({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        {/* favicon, meta, stylesheets, and scripts go here */}\n        <link href=\"my-font-source\" rel=\"stylesheet\" />\n      </Head>\n      {/* render the page */}\n      <Component {...pageProps} />\n    </>\n  );\n}\n```\n\n## Styles\n\nNext.js comes with support for **CSS modules** (`.module.css`). Their per-file class name mangling is a great solution to CSS collision problems. While CSS modules can be imported from any JavaScript file, the traditional CSS can only be imported in `_app.js`. That's exactly where I put all my stylesheets since this project relies on global CSS exclusively.\n\nI must mention the use of **CSS variables**. For some strange reason, the community has not adopted that technology, despite its [high browser compatibility](https://caniuse.com/#search=css%20variables) (94.81% of browsers as of 2020-05). In my project, variables describing fonts, font sizes, and colors live in the `variables.css` file. Styles shared between pages are placed in `global.css`. All other CSS files are responsible for styling components.\n\nTo cope with class collisions and give stylesheets a solid backbone, I followed [BEM methodology](http://getbem.com/). Well, with some small modifications. I name BEM components with _PascalCase_ and BEM elements with _camelCase_. All in all, I am really happy with how styles turned out. My blog looks pretty both in the browser and in the editor!\n\n## Components\n\nSeparating independent units of the user interface is a common practice in front-end frameworks. It encourages reusability and makes complex applications more manageable. Components of this blog live in `src/components` folder.\n\n# Results and conclusion\n\nThe source code of the blog is [available on GitHub](https://github.com/prk3/blog-source). Generating truly static and lightweight pages required a bit of effort, mostly because of rehydration, which can be disabled only with the undocumented, experimental feature of Next. All in all, I am happy with the result and will definitely put the blog into use.\n\nWould I use static generation in serious, not \"for-fun\" projects? Probably not. It's hard to deny that static pages are not very useful these days. Even the most obvious use cases of static site generation, like blogs or documentation pages, benefit greatly from dynamic content such as comments or search results. Maybe it's good enough for static portfolio pages? In the end, if you need to make a hole in a slice of bread, it does not matter if you use your finger, a screwdriver, or an electric drill.\n\nNext.js is not a regular static site generator. It's a framework that brings together the best of three worlds: static generation, server-side rendering, and client-side interactive interfaces. If you think how React applications are usually loaded and run, you realize that with Next's server-side rendering you can speed up the initial render by skipping up to 3 sequential HTTP requests. This is a massive improvement especially for users with a poor internet connection. I would like to see how Next is used in more complex products. Are the benefits worth the transition from pure React? Does Next maintain the separation of back-end logic from user interface logic?\n"}],"tags":{"typescript":{"title":"TypeScript","color":"#294e80"},"markdown":{"title":"Markdown","color":"#000000"},"nextjs":{"title":"Next.js","color":"#000000"},"functional":{"title":"Functional","color":"#703c83"}},"config":{"author":{"name":"PrzemysÅ‚aw Kukulski","email":"kukulski.przemyslaw@gmail.com"},"title":"prk3 blog"}},"__N_SSG":true}